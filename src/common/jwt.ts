/// <reference path="../../typings/tsd.d.ts" />declare var config;import {debug, error, info, log, warn} from 'winston';//import {Request, Response} from 'express';import {Request, Response, HttpHeaders, IUnless} from './extensions/extensions'import {BadRequestError, UnauthorizedError, ServerError} from './error';import {join as joinPaths, resolve as resolvePaths} from 'path';import Http = require('http');import {decode as decodeJwt, sign as signJwt, verify as verifyJwt} from 'jsonwebtoken';import {readFileSync} from 'fs-extra';var Moment = require('moment');var PATH_TO_CONFIG = '../config/keystore/%s';var publicKey = readFileSync(resolvePaths(__dirname, PATH_TO_CONFIG.sprintf(config.app.public_key)));var privateKey = readFileSync(resolvePaths(__dirname, PATH_TO_CONFIG.sprintf(config.app.private_key)));export class NumericDate {  constructor(public value?: number | Date) {    if (value instanceof Date) {      this.value = Moment(value).unix();    } else if (typeof value === 'number') {      this.value = value;    } else {      this.value = Moment.unix();    }  }  toDate(): Date {    return  Moment.unix(this.value).toDate();  }}export class Token {  constructor(public token: string, public expires: NumericDate) {  }}export class Context {  constructor(public id: string,              public userName: string,              public email: string,              public firstName: string,              public lastName: string,              public modified: Date) {  }}function fetch(headers: HttpHeaders): string {  if (headers && headers.authorization) {    var authorization = headers.authorization;    var part = authorization.split(' ');    if (part.length === 2) {      var token = part[1];      return part[1];    } else {      return null;    }  } else {    return null;  }}export function create(context: Context): Token {  debug('Create token');  if (Object.isNullOrUndefined(context))    throw new BadRequestError();  var token = null,      decoded = null,      expires = null;  try {    // Create jwt token    token = signJwt({                      context: context                    },                    privateKey,                    {                      algorithm: 'RS256',                      issuer: config.app.jwt_token_issuer,                      subject: context.userName,                      expiresInMinutes: (config.app.jwt_token_expiration * 60)                    });    // Decode to retrieve expires    decoded = decodeJwt(token);    // Created token object to return    token = new Token(token, decoded.exp);    debug('Token generated for user: %s, token: %s, expires: %s'          .sprintf(context.userName,                   JSON.stringify(token),                   Moment.unix(token.expires).format('MM/DD/YYYY HH:mm:ss')));  } catch (err) {    error(err.stack);  }  return token;}function verify(token: string): any {  debug('Verify token');  var decoded = null;  try {    decoded = verifyJwt(token,                        publicKey,                        {                          issuer: config.app.jwt_token_issuer                        },                        undefined); // This is a hack. The type definition file should have                                    // this parameter as option. Which means the method                                    // executes synchronously.  } catch (err) {    error(err.stack);  }  return decoded;}function refresh(decoded: any): Token {  var expiration,      now,      newToken;  expiration = decoded.exp;  now = Moment().unix().valueOf();  if((expiration - now) < (config.app.jwt_token_refresh_expiration * 60 * 60)) {    newToken = create(decoded.context);    if(newToken) {      // Retrieve new expiration and return the new Token      return new Token(newToken, decodeJwt(newToken).exp);    }  } else {    return null;  }}export function middleware() {  var func: IUnless = (req: Request,                       res: Response,                         next: Function): Function => {                         var decoded = null;                         var err: ServerError = null;                         var token = fetch(<HttpHeaders> req.headers);                         try {                           decoded = verify(token);                         } catch (e) {                            err = e;                         }                         if ((err) || (decoded==null)) {                           if (err)                             error(err.stack);                           req.user = undefined;                           err = new UnauthorizedError();                           res.status(err.status)                              .json(err);                           return null;                         } else {                           // Slide the token expiration                           var newToken = refresh(decoded);                           if (newToken) {                             res.headers.authorization = JSON.stringify(newToken);                           }                           req.user = Object.merge(req.user, decoded.context);                           return next();                        }                       };  func.unless = <IUnless> require('express-unless');  return func;}